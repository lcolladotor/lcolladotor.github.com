<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parallel on L. Collado-Torres</title>
    <link>/tags/parallel/</link>
    <description>Recent content in Parallel on L. Collado-Torres</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2011-2018 Leonardo Collado Torres under (CC) BY-NC-SA 4.0</copyright>
    <lastBuildDate>Mon, 07 Mar 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/parallel/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Are you doing parallel computations in R? Then use BiocParallel</title>
      <link>/2016/03/07/BiocParallel/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/2016/03/07/BiocParallel/</guid>
      <description>It&#39;s the morning of the first day of oral conferences at #ENAR2016. I feel like I have a spidey sense since I woke up 3 min after an email from Jeff Leek; just a funny coincidence. Anyhow, I promised Valerie Obenchain at #Bioc2014 that I would write a post about one of my favorite Bioconductor packages: BiocParallel (Morgan, Obenchain, Lang, and Thompson, 2016). By now it&#39;s on the top 5% of downloaded Bioconductor packages, so many people know about it or are unaware that their favorite package uses it behind the scenes.</description>
    </item>
    
    <item>
      <title>Trying to reduce the memory overhead when using mclapply</title>
      <link>/2013/11/14/Reducing-memory-overhead-when-using-mclapply/</link>
      <pubDate>Thu, 14 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>/2013/11/14/Reducing-memory-overhead-when-using-mclapply/</guid>
      <description>I am currently trying to understand how to reduce the memory used by mclapply. This function is rather complicated and others have explained the differences versus parLapply (A_Skelton73, 2013; lockedoff, 2012 ) and also made it clear that in mclapply each job does not know if the others are running out of memory and thus cannot trigger gc (Urbanek, 2012).
While I still struggle to understand all the details of mclapply, I can successfully use it to reduce computation time at the expense of a very high memory load.</description>
    </item>
    
    <item>
      <title>Using plyr and doMC for quick and easy apply-family functions</title>
      <link>/2013/04/26/using-plyr-and-domc-for-quick-and-easy-apply-family/</link>
      <pubDate>Fri, 26 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/2013/04/26/using-plyr-and-domc-for-quick-and-easy-apply-family/</guid>
      <description>A few weeks back I dedicated a short amount of time to actually read what plyr (Wickham, 2011) is about and I was surprised. The whole idea behind plyr is very simple: expand the apply() family to do things easy. plyr has many functions whose name ends with ply which is short of apply. Then, the functions are identified by two letters before ply which are abbreviations for the input (first letter) and output (second one).</description>
    </item>
    
  </channel>
</rss>